4 Лабораторная работа №2.\
Преобразование текстов с использованием генератора лексических
анализаторов flex

Теоретические сведения

Общие сведения

Построение НКА и ДКА для лексем большинства компьютерных языков вручную
является трудоёмкой задачей, требующей повышенного внимания и тщательной
проверки полученных результатов, причём даже незначительные изменения в
лексической спецификации языка могут потребовать повторного выполнения
всех преобразований.

Как правило, при разработке трансляторов для сложных компьютерных языков
применяют инструменты, автоматизирующие наиболее трудоёмкие
преобразования. Одним из таких инструментов стала утилита lex,
первоначально разработанная Майком Леском и Эриком Шмидтом и ставшая
стандартным генератором лексических анализаторов в операционных системах
UNIX, а также включённая в стандарт POSIX.

К настоящему времени в ходе развития инструментария на смену
классической утилите lex пришла flex, которая, однако, в значительной
степени сохранила обратную совместимость с lex. Существует несколько
реализаций flex для ОС Windows, имеющих ряд несущественных отличий. В
данном методическом пособии будет рассмотрена реализация flex в рамка
проекта GNU Win32.

Flex --- это генератор лексических анализаторов, исходными данными для
которого является лексическая спецификация анализируемого языка, а
результатом --- исходный код лексического анализатора, способного
выполнять разбор этого языка.

Описание для flex представляет собой текстовый файл, который в общем
случае состоит из трёх секций:

\... Определения \...

%%

\... Правила \...

%%

\... Подпрограммы \...

Секция определения содержит объявления вспомогательных символов и
начальных условий. Секция правил задаёт поведение лексического
анализатора при обнаружении в анализируемом тексте тех или иных
последовательностей символов. Содержимое секции подпрограмм просто
копируется в генерируемый flex модуль лексического анализатора.

Секция правил является обязательной, поэтому простейшее описание для
flex выглядит следующим образом:

%%

Полученный в результате обработки такого описания лексический анализатор
будет выполнять посимвольное копирование анализируемых текстов из потока
ввода в поток вывода, т.к. действием по умолчанию является именно
копирование.

Между тем, сгенерированного flex кода в этом случае будет недостаточно
для сборки проекта. В частности, для такого описания flex не сгенерирует
код для двух функций: main(), являющейся точкой входа программы, и
yywrap() --- вспомогательной функции, определяющей поведение
лексического анализатора по окончании анализируемого текста.

Для более гибкой настройки flex может использоваться специальная
директива %option, указываемая в секции определений (первой секции
файла-описания). Допускается указание нескольких таких директив, а также
указание нескольких опций (настроек) в одной директиве. Большинство
опций задаётся именем, которое может дополняться словом no. Кроме того,
ряд опций может быть задан не только с помощью данной директивы, но и
при запуске flex из командной строки.

К числу опций, доступных только из файла-описания, относятся yywrap и
main. Первая, в случае отрицания, указывает flex, что по окончании
анализируемого текста сгенерированный лексический анализатор должен
считать, что больше нет файлов, требующих обработки, и возвращать
управление вызывающей программе. Вторая опция заставляет flex помимо
кода лексического анализатора сгенерировать и функцию main(). При этом
опция main автоматически устанавливает и опцию noyywrap.

Таким образом, минимальное описание, позволяющее получить готовую к
компиляции программу, выглядит так:

%option main

%%

Сохраним описание в файл с именем Test1.l. Теперь для генерации
лексического анализатора необходимо запустить flex из командной строки,
передав файл-описание в качестве параметра. В простейшем случае команда
будет выглядеть так:

flex Test1.l

В случае отсутствия ошибок в файле-описании flex создаст файл lex.yy.c,
который и будет содержать сгенерированный лексический анализатор.
Соответствующий исполняемый файл будет представлять собой консольное
приложение, которое выводит на экран вводимые пользователем строковые
данные. Чтобы завершить работу программы можно ввести специальный символ
с кодом 26, который интерпретируется стандартной библиотекой C/C++ как
признак конца текстового файла. Для этого необходимо нажать сочетание
клавиш Ctrl + Z и завершить ввод.

![](media/image1.png){width="6.49375in" height="3.395138888888889in"}

Рисунок 6. Простейший лексический анализатор, сгенерированный flex

Полученная программа считывает исходные данные из стандартного потока
ввода (stdin) и записывает результаты обработки в стандартный поток
вывода (stdout). Благодаря этому возможно использовать перенаправление
для обработки с её помощью произвольных файлов, например, так:

test1 \< input.txt \> output.txt

где test1 --- имя исполняемого файла, input.txt и output.txt ---
соответственно имена исходного файла и файла с результатами обработки.
При таком способе запуска полученная программа будет осуществлять
посимвольное копирование файлов.

Сгенерированная flex функция main() имеет следующий вид:

int main()

{

yylex();

return 0;

}

Таким образом, эта функция является всего лишь обёрткой, запускающей
функцию yylex(), которая и реализует лексический анализатор.

Как правило, лексический анализатор является лишь частью большой
программы. В этом случае автоматически сгенерированная функция main()
оказывается ненужной. Чтобы заставить flex сгенерировать лексический
анализатор без этой функции, но при этом не требовать реализации функции
yywrap(), можно использовать другой параметр директивы %option:

%option noyywrap

%%

В этом случае вызов функции yylex() должен будет выполнить программист.

Для того, чтобы лексический анализатор делал что-нибудь более полезное,
необходимо заполнить его секцию правил (вторую). Например, такое
описание

%option main

%%

username printf(\"User12345\");

приведёт к генерации кода лексического анализатора, который будет
копировать исходный текст в выходной поток, заменяя подстроки username
на User12345.

![](media/image2.png){width="6.49375in" height="3.395138888888889in"}

Рисунок 7. Лексический анализатор, заменяющий подстроку username

Левая часть правила называется *шаблоном*, правая --- *действием*. Как
было показано ранее, действие по умолчанию заключается в выводе каждого
прочитанного символа. Однако если какая-либо подстрока во входном тексте
соответствует шаблону, лексический анализатор будет выполнять
соответствующее действие. Действия представляют собой фрагменты кода на
языке C, которые встраиваются в сгенерированный лексический анализатор.

Рассмотрим более сложный пример:

%option noyywrap

%{

int nLines = 0, nChars = 0;

%}

%%

\\n {

++nLines; ++nChars;

}

. ++nChars;

%%

int main()

{

yylex();

printf(\"Lines: %d. Characters: %d\", nLines, nChars);

}

Работа функции main() будет отличаться от стандартной реализации,
поэтому вместо %option main используется директива %option noyywrap,
смысл которой уже был описан ранее: она позволяет избавиться от
необходимости самостоятельно реализовывать функцию yywrap(), которую
сгенерированный лексический анализатор вызывает, когда доходит до конца
обрабатываемого им файла.

В секциях определений и правил текст, записанный с отступами или
заключённый между %{ и %}, копируется в модуль лексического анализатора
в неизменном виде. При этом %{ и %} должны быть записаны в отдельных
строках без отступов. Следовательно, следующие три строки заставляют
flex вставить в модуль лексического анализатора объявление с
инициализацией двух целочисленных переменных --- nLines и nChars.

Далее следует раздел правил. Шаблон, записываемый в левой части правила,
является регулярным выражением. Шаблон \\n соответствует символу с кодом
10 (Line Feed), шаблон . означает «любой символ, кроме перевода строки
(Line Feed)». Соответствующие этим шаблонам действия приводят к тому,
что для любого символа входной последовательности будет наращиваться
значение переменной nChars, а для символа перевода строки, кроме того,
будет наращиваться и значение переменной nLines.

Содержимое секции подпрограмм включается в код генерируемого flex модуля
без изменений.

Таким образом, программа, генерируемая для приведённого описания,
осуществляет подсчёт символов и строк, подаваемых на вход, и выводит
результаты подсчётов. Этот и последующие примеры наиболее удобно
рассматривать с использованием перенаправления в файлы, как было
показано ранее.

Синтаксис шаблонов flex

Шаблоны в файле-описании представляют собой расширенные регулярные
выражения. Основные конструкции, которые могут применяться в шаблонах,
приведены в таблице 6.

В символьных классах кроме перечисления символов и диапазонов могут
применяться специальные обозначения, задающие наиболее часто
используемые подмножества символов. Список таких обозначений приведён в
таблице 7. В частности, следующие шаблоны эквивалентны:

\[\[:alnum:\]\]

\[\[:alnum:\]\[:digit:\]\]

\[\[:alpha:\]0-9\]

\[a-zA-z0-9\]

Также следует помнить, что внутри конструкции, задающей символьный
класс, все спецсимволы регулярных выражений, такие как, например, \* или
\| теряют своё особое значение и становятся обычными символами.
Исключение составляют символ экранирования \\, спецсимволы, используемые
при задании символьного класса (- и \]) и расположенный в начале
описания символьного класса символ \^.

Важно принимать во внимание приоритет операций. Приведённые в таблице 6
операции (конкатенация, альтернатива и др.) перечислены в порядке
убывания приоритета. Так, например, шаблон

foo\|bar\*

эквивалентен шаблону

(foo)\|(ba(r\*))

т.к. операция \* имеет более высокий приоритет, чем конкатенация.
Шаблон, задающий альтернативу между одиночным foo и повторением 0 или
более раз bar, можно записать следующим образом:

foo\|(bar)\*

Повторение же foo или bar запишется так:

(foo\|bar)\*

Таблица 6. Основные конструкции, используемые в шаблонах правил flex

+-----------------------+----------------------------------------------+
| Шаблон                | Значение                                     |
+=======================+==============================================+
| X                     | Соответствует символу x                      |
+-----------------------+----------------------------------------------+
| .                     | Любой символ (байт), кроме перевода строки   |
+-----------------------+----------------------------------------------+
| \[xyz\]               | Символьный класс. В этом примере             |
|                       | соответствует одному из символов x, y или z. |
+-----------------------+----------------------------------------------+
| \[abj-oZ\]            | Символьный класс. В этом примере             |
|                       | соответствует символу a, символу b, одному   |
|                       | из символов от j до o или символу Z.         |
+-----------------------+----------------------------------------------+
| \[\^A-Z\]             | Символьный класс с отрицанием. Соответствует |
|                       | любому символу, кроме входящих в символьный  |
|                       | класс. В этом примере --- любой символ,      |
|                       | кроме символов от A до Z.                    |
+-----------------------+----------------------------------------------+
| \[\^A-Z\\n\]          | Символьный класс с отрицанием. В этом        |
|                       | примере --- любой символ, кроме символов от  |
|                       | A до Z и символа перевода строки.            |
+-----------------------+----------------------------------------------+
| r\*                   | 0 или более раз r, где r --- произвольный    |
|                       | шаблон.                                      |
+-----------------------+----------------------------------------------+
| r+                    | 1 или более раз r, где r --- произвольный    |
|                       | шаблон.                                      |
+-----------------------+----------------------------------------------+
| r?                    | 0 или 1 раз r, где r --- произвольный        |
|                       | шаблон.                                      |
+-----------------------+----------------------------------------------+
| r{2,5}                | От 2 до 5 раз r.                             |
+-----------------------+----------------------------------------------+
| r{2,}                 | 2 и более раза r.                            |
+-----------------------+----------------------------------------------+
| r{4}                  | 4 раза r.                                    |
+-----------------------+----------------------------------------------+
| {name}                | Подстановка определения name. Используется   |
|                       | для сокращения описания. Определение должно  |
|                       | быть задано в секции определений.            |
+-----------------------+----------------------------------------------+
| \"\[xyz\]\\\"foo\"    | Строковый литерал: \[xyz\]\"foo              |
+-----------------------+----------------------------------------------+
| \\X                   | Если X --- один из символов a, b, f, n, r, t |
|                       | или v, означает запись символа по правилам   |
|                       | ANSI C (аналогично строковым константам в    |
|                       | языке C).                                    |
|                       |                                              |
|                       | В остальных случаях означает символ X.       |
|                       | Используется для экранирования спецсимволов  |
|                       | наподобие \*.                                |
+-----------------------+----------------------------------------------+
| \\0                   | Символ с кодом 0.                            |
+-----------------------+----------------------------------------------+
| \\123                 | Символ с кодом 123~(8)~.                     |
+-----------------------+----------------------------------------------+
| \\x2a                 | Символ с кодом 2A~(16)~.                     |
+-----------------------+----------------------------------------------+
| \(r\)                 | Круглые скобки используются для изменения    |
|                       | приоритетов.                                 |
+-----------------------+----------------------------------------------+
| rs                    | Конкатенация строки, заданной шаблоном r, со |
|                       | строкой, заданной шаблоном s.                |
+-----------------------+----------------------------------------------+
| r\|s                  | Либо r, либо s.                              |
+-----------------------+----------------------------------------------+
| r/s                   | r при условии, что далее следует s. После    |
|                       | того, как получено совпадение с шаблоном r,  |
|                       | лексический анализатор будет просматривать   |
|                       | последующий текст на предмет совпадения с    |
|                       | шаблоном s (предпросмотр). Следует           |
|                       | использовать с осторожностью, т.к. не все    |
|                       | варианты s корректно обрабатываются flex.    |
+-----------------------+----------------------------------------------+
| \^r                   | r, но только в начале строки.                |
+-----------------------+----------------------------------------------+
| r\$                   | r, но только в конце строки (эквивалентно    |
|                       | r/\\n).                                      |
+-----------------------+----------------------------------------------+

Таблица 7. Подмножества символов для символьных классов

  -----------------------------------------------------------------------
  Обозначение             Значение
  ----------------------- -----------------------------------------------
  \[:alnum:\]             Символы алфавита (буквы) и арабские цифры.

  \[:alpha:\]             Символы алфавита (буквы).

  \[:blank:\]             Пробел и символ табуляции.

  \[:cntrl:\]             Управляющие символы.

  \[:digit:\]             Арабские цифры.

  \[:graph:\]             Символы, имеющие графическое представление (все
                          печатные символы, кроме пробела).

  \[:lower:\]             Строчные буквы.

  \[:print:\]             Печатные символы (все, кроме управляющих).

  \[:punct:\]             Знаки пунктуации.

  \[:space:\]             Пробельные символы (пробел, символ табуляции,
                          возврат каретки, перевод строки и т.п.)

  \[:upper:\]             Прописные буквы.

  \[:xdigit:\]            16-чные цифры.
  -----------------------------------------------------------------------

За информацией о поддержке национальных алфавитов (букв, отличных от
латиницы) следует обращаться к документации конкретной версии flex.

Действия в правилах flex-описаний

Правая часть правила во flex-описаниях задаёт действия, которые
необходимо выполнить при выявлении в анализируемом тексте подстроки,
соответствующей шаблону из левой части правила.

Действие может быть произвольным фрагментом кода на языке C. При этом,
flex учитывает лексическую структуру языка C и, если действие начинается
с открывающей фигурной скобки {, продолжит копировать такой фрагмент
кода до момента, пока не встретит соответствующую ей закрывающую
фигурную скобку }. Тем не менее, допускается также обрамление действия
скобками в стиле flex: %{ \... }%.

Если действие состоит из единственной вертикальной черты \|, это
означает «такое же действие, как и для следующего правила».

Код действия может быть совершенно произвольным, в том числе содержать
оператор return. Поскольку код действия подставляется в генерируемую
flex функцию лексического анализа yylex(), такой оператор заставить эту
функцию вернуть произвольное значение из лексического анализатора. При
каждом вызове функция yylex() продолжает анализ исходного текста с того
места, где произошла остановка при предыдущем вызове. В частности это
полезно при разработке трансляторов, в которых вместо преобразования
текстов требуется разбиение исходного текста на смысловые единицы ---
лексемы.

Действия могут получить доступ к фрагменту анализируемого текста,
который совпал с шаблоном, обращаясь к переменной yytext. Эта переменная
может объявляться как указатель char \* или как массив char.
Контролировать эту особенность можно явным указанием одной из директив:
%pointer или %array. Использование %pointer повышает быстродействие
генерируемого анализатора, однако ограничивает разработчика в допустимых
действиях над переменной yytext.

При генерации кода flex также определяет несколько макросов для наиболее
часто используемых действий. Одно из таких действий ---
ECHO ---выполняет копирование yytext в выходной поток.

Ещё одно предопределённое действие --- REJECT. Оно заставляет
сгенерированный анализатор перейти к обработке следующего правила по
степени соответствия шаблона строке. Суть такого действия можно показать
на примере следующего описания:

%option noyywrap

int nWords = 0;

%%

frob special(); REJECT;

\[\^ \\t\\n\]+ ++nWords;

Данное описание предназначено для подсчёта количества слов в
анализируемом тексте с дополнительной обработкой вхождений слова frob.
Сгенерированный flex анализатор всегда выбирает одно наиболее подходящее
подстроке правило. Слово frob соответствует шаблонам обоих правил,
однако шаблон первого правила при этом более конкретный, поэтому для
обработки будет выбрано именно оно. Однако если убрать обращение к
REJECT из соответствующего действия, слово frob обрабатывалось бы
исключительно вызовом функции special(), а значит, наращивание счётчика
слов либо не производилось бы вовсе, либо должно было бы быть включено в
саму функцию special().

Код, записанный после REJECT, выполнен не будет. Кроме того, следует
помнить, что это действие снижает производительность анализатора, а
также не может использоваться вместе с некоторыми настройками flex.

Задание

Для заданного вариантом способа преобразование текстовых данных
разработать:

- **flex-описание** анализатора;

- **программное средство**, сгенерированное на основе описания и
  выполняющее заданное преобразование.

Программное средство должно преобразовывать данные, поступающие из
стандартного потока ввода stdin и выводить результат своей работы в
стандартный поток вывода stdout.

Таблица 8. Варианты заданий к лабораторной работе №2

+----------+-------------------------+---------------------------------+
| Номер    | Исходный текст          | Преобразование                  |
| варианта |                         |                                 |
+==========+=========================+=================================+
| 1        | Программа на языке      | Удалить комментарии:\           |
|          | Pascal                  | (\* ... \*) и { ... }.\         |
|          |                         | \                               |
|          |                         | Директивы компилятора не        |
|          |                         | удалять.                        |
+----------+-------------------------+---------------------------------+
| 2        | Программа на языке C    | Удалить комментарии:            |
|          |                         |                                 |
|          |                         | /\* ... \*/ и // ...            |
+----------+-------------------------+---------------------------------+
| 3        | HTML-документ           | Удалить комментарии:\           |
|          |                         | \<!\-- ... \--\>                |
+----------+-------------------------+---------------------------------+
| 4        | Текстовый файл          | Добавить отступ в 4 пробела в   |
|          |                         | начало каждого абзаца.\         |
|          |                         | \                               |
|          |                         | Абзацами считать фрагменты      |
|          |                         | текста, разделённые пустой      |
|          |                         | строкой.                        |
+----------+-------------------------+---------------------------------+
| 5        | Текстовый файл          | Привести расстановку пробелов   |
|          |                         | вокруг знаков препинания к      |
|          |                         | следующему виду:\               |
|          |                         | \* пробел не ставится перед и   |
|          |                         | ставится после следующих знаков |
|          |                         | препинания: .,!?:;)             |
|          |                         |                                 |
|          |                         | \* пробел ставится перед и не   |
|          |                         | ставится после открывающей      |
|          |                         | круглой скобки.                 |
+----------+-------------------------+---------------------------------+
| 6        | HTML-документ           | Преобразовать документ так,     |
|          |                         | чтобы все теги и содержимое     |
|          |                         | парных тегов начинались с новой |
|          |                         | строки:                         |
|          |                         |                                 |
|          |                         | \<!DOCTYPE html\>\              |
|          |                         | \<html\>                        |
|          |                         |                                 |
|          |                         | \<head\>                        |
|          |                         |                                 |
|          |                         | \<title\>                       |
|          |                         |                                 |
|          |                         | Test file                       |
|          |                         |                                 |
|          |                         | \</title\>                      |
|          |                         |                                 |
|          |                         | \</head\>                       |
|          |                         |                                 |
|          |                         | \<body\>                        |
|          |                         |                                 |
|          |                         | \<p\>                           |
|          |                         |                                 |
|          |                         | Hello, world!                   |
|          |                         |                                 |
|          |                         | \</p\>                          |
|          |                         |                                 |
|          |                         | \</body\>                       |
|          |                         |                                 |
|          |                         | \</html\>                       |
+----------+-------------------------+---------------------------------+
| 7        | Текстовый файл          | Удалить пробельные символы,     |
|          |                         | записанные в начале строки.     |
+----------+-------------------------+---------------------------------+
| 8        | Текстовый файл          | Подсчитать, сколько раз в       |
|          |                         | тексте использованы названия    |
|          |                         | операционных систем Windows,    |
|          |                         | Linux и Android. Получившиеся   |
|          |                         | числа вывести в выходной файл   |
|          |                         | по одному в строке.             |
+----------+-------------------------+---------------------------------+
| 9        | Текстовый документ с    | Определить и вывести долю       |
|          | перепиской в формате:\  | сообщений пользователя с именем |
|          | \                       | Admin, в процентах от общего    |
|          | Имя1: Текст сообщения\  | количества сообщений.           |
|          | Имя2: Текст сообщения\  |                                 |
|          | ...                     |                                 |
+----------+-------------------------+---------------------------------+
| 10       | Текстовый документ      | Зашифровать текст шифром        |
|          |                         | Цезаря. Шифрованию подвергать   |
|          |                         | только латинские буквы.         |
+----------+-------------------------+---------------------------------+
| 11       | Текстовый документ      | Пронумеровать строки.           |
|          |                         | Результатом работы должен быть  |
|          |                         | текстовый документ, в котором   |
|          |                         | перед началом каждой строки     |
|          |                         | записан её порядковый номер.    |
+----------+-------------------------+---------------------------------+
| 12       | Текстовый документ      | Раскодировать содержащиеся в    |
|          |                         | тексте                          |
|          |                         | urlencoded-последовательности.  |
|          |                         | Например, текст\                |
|          |                         | \                               |
|          |                         | Привет%20всем!\                 |
|          |                         | \                               |
|          |                         | превратить в\                   |
|          |                         | \                               |
|          |                         | Привет␣всем!                    |
|          |                         |                                 |
|          |                         | После символа % указывается код |
|          |                         | символа в 16-чной системе       |
|          |                         | счисления.                      |
+----------+-------------------------+---------------------------------+
| 13       | Программа на языке      | Выделить все использованные в   |
|          | Pascal                  | программе строковые литералы и  |
|          |                         | записать их значения (без       |
|          |                         | кавычек) по одному в строке.    |
+----------+-------------------------+---------------------------------+
| 14       | Программа на языке C    | Выделить все использованные в   |
|          |                         | программе строковые литералы и  |
|          |                         | записать их значения (без       |
|          |                         | кавычек) по одному в строке.    |
+----------+-------------------------+---------------------------------+
| 15       | Программа на языке      | Подсчитать и вывести количество |
|          | ассемблера (диалект     | глобальных, локальных и         |
|          | FASM)                   | анонимных меток, использованных |
|          |                         | в программе.                    |
+----------+-------------------------+---------------------------------+
