5 Лабораторная работа №3.\
Разработка синтаксического анализатора,
основанного на методе рекурсивного спуска

Теоретические сведения

Общие сведения

Синтаксический анализ --- это этап трансляции, задача которого
заключается в построении древовидного представления анализируемого
текста (например, исходного кода программы). Как правило, на вход
синтаксическому анализатору (который также называют *парсером*) подаются
токены, получаемые в результате обработки анализируемого текста
лексическим анализатором.

Теоретически возможно записать грамматику, терминалами в которой будут
символы в той или иной кодировке, однако такая грамматика для
большинства применяемых на практике компьютерных языков окажется излишне
громоздкой, т.к. должна будет учитывать возможность появления пробельных
символов или комментариев между любыми двумя лексемами.

Построение *дерева разбора* может выполняться в одном из двух
направлений: от корня к листьям или от листьев к корню. По этому
принципу методы синтаксического анализа принято разделять на две большие
группы:

- нисходящие --- дерево строится от корня к листьям;

- восходящие --- дерево строится от листьев к корню.

Независимо от порядка построения листья в деревьях разбора содержат
терминальные символы грамматики, промежуточные узлы (в т.ч. и
корневой) --- нетерминалы. При этом любой фрагмент дерева разбора,
состоящий из промежуточного узла и его дочерних элементов, в точности
соответствует одной из продукций грамматики --- той, в левой части
которой записан нетерминал из выбранного промежуточного узла, а в
правой --- последовательно заданы терминалы и нетерминалы дочерних
узлов.

Очевидным недостатком деревьев разбора является зависимость их структуры
от структуры грамматики. Фактически это означает, что любое изменение в
грамматике может существенно изменить структуру дерева разбора, что
потребует внесения изменений в код, отвечающий за последующие этапы
трансляции. По этой причине более целесообразным, как правило,
оказывается использование вместо деревьев разбора так называемых
*абстрактных синтаксических деревьев* (abstract syntax trees --- AST).

Конкретный способ представления тех или иных синтаксических конструкций
языка в AST выбирается разработчиком транслятора исходя из специфики
решаемой задачи. Тем не менее, как правило, AST представляет собой
отражение логической структуры анализируемого текста, не зависящей от
состава продукций грамматики.

Неоднозначные грамматики

Наиболее широко в синтаксическом анализе применяются
контекстно-свободные грамматики. Это обусловлено, с одной стороны, их
достаточно широкими возможностями для описания большинства компьютерных
языков, а с другой --- наличием детально проработанных методов разбора.

При разработке грамматики для синтаксического анализатора важно
понимать, что не все контекстно-свободные грамматики подходят для
практического применения.

Рассмотрим следующую грамматику:

*Expr* → *Expr* + *Expr*

\| *Expr* \* *Expr*

\| int

Данная грамматика задаёт произвольные выражения, состоящие из целых
чисел и операций сложения и умножения, при этом запись грамматики
достаточно проста и наглядна. Тем не менее, у неё есть один существенный
недостаток, делающий невозможным её практическое применение.

![](media/image1.png)

Рисунок 9. Деревья разбора при неоднозначной грамматике

Рассмотрим последовательность токенов:

int + int \* int

Вышеприведённая грамматика способна породить такую строку, однако может
сделать это несколькими различными способами. При этом, как показано на
рисунке 9, эти способы будут отличаться приоритетами операций. В
частности, дерево разбора, приведённое слева, задаёт выражение как
произведение суммы на число, а дерево разбора, приведённое справа, ---
как сумму числа и произведения.

Очевидно, данная грамматика позволяет проверить синтаксическую
корректность строки, но не задаёт приоритета операций. Решение этой
проблемы заключается в том, чтобы переписать грамматику.

Expr → ExprMul + Expr \| ExprMul

ExprMul → int \* ExprMul \| int

При этом в результате анализа той же самой строки будет возможно
построение только дерева разбора, показанного на рисунке 10.

![](media/image2.png)

Рисунок 10. Дерево разбора для однозначной грамматики

Определить, является ли некоторая грамматика неоднозначной, в общем
случае алгоритмически невозможно. Тем не менее, для некоторых методов
синтаксического разбора необходимо построение вспомогательных структур
данных и для неоднозначных грамматик их построение оказывается
невозможным.

Метод рекурсивного спуска

Простым в реализации и вместе с тем эффективным методом синтаксического
анализа является *метод рекурсивного спуска*. Суть данного метода
заключается в том, что начиная со стартового символа грамматики
поочерёдно перебираются все возможные комбинации продукций до тех пор,
пока не будет найдено порождение, соответствующее анализируемому тексту,
либо пока не окажется, что такого порождения не существует.

Рассмотрим метод рекурсивного спуска на примере следующей грамматики
(курсивным начертанием обозначены нетерминалы, обычным --- терминалы):

*Operator* → *Operator_If* \| int

*Operator_If* → if *Operator* then *Operator* endif

\| if *Operator* then *Operator* else *Operator* endif

Пусть получаемые из лексического анализатора токены формируют следующий
поток:

if int~5~ then if if int~8~ then int~9~ endif then int~11~ else if
int~3~ then int~4~ else int~6~ endif endif endif

Тогда ход работы синтаксического анализатора, основанного на методе
рекурсивного спуска, будет следующим. На начальном этапе дерево разбора
состоит из единственного узла, соответствующего стартовому символу
грамматики, при этом ни один символ из последовательности токенов не
прочитан.

![](media/image3.png)

Рисунок 9. Дерево разбора и поток токенов (шаг 1)

Узел в данный момент является текущим и соответствует нетерминалу. Для
нетерминалов выполняется их раскрытие поочерёдно в соответствии с каждой
из имеющихся продукций. Таким образом, на следующем шаге дерево разбора
дополняется дочерними элементами по первой продукции символа *Operator*
и первый из этих элементов становится текущим. В данном случае такой
элемент является единственным.

![](media/image4.png)

Рисунок 10. Дерево разбора и поток токенов (шаг 2)

Текущим символом является нетерминал. Дерево разбора снова необходимо
дополнить дочерними элементами в соответствии с продукцией этого
нетерминала. Текущим при этом станет первый из этих элементов.

![](media/image5.png)

Рисунок 11. Дерево разбора и поток токенов (шаг 3)

Текущим символом является терминал, а это означает, что необходимо
сопоставить его с символом из входного потока токенов. В данном случае
имеет место совпадение, поэтому указатель входного потока передвигается
к следующему символу и следующий узел дерева становится текущим.

![](media/image6.png)

Рисунок 12. Дерево разбора и поток токенов (шаг 4)

Текущим символом является нетерминал, поэтому производится дополнение
дерева разбора дочерними элементами в соответствии с первой продукцией
этого нетерминала.

![](media/image7.png)

Рисунок 13. Дерево разбора и поток токенов (шаг 5)

Текущий символ является нетерминалом, дерево разбора дополняется
элементами в соответствии с первой продукцией этого нетерминала.

![](media/image8.png)

Рисунок 14. Дерево разбора и поток токенов (шаг 6)

Текущий символ является терминалом, однако его тип не совпадает с
классом токена из входного потока. Это означает, что выбранная продукция
не подходит. Необходимо выполнить откат и попробовать применить другую
продукцию.

![](media/image9.png)

Рисунок 15. Дерево разбора и поток токенов (шаг 7)

Текущий символ снова является терминалом и снова не соответствует
входному потоку. Необходимо перейти к следующей продукции нетерминала
*Operator_If*, однако эта продукция была последней. Значит, следует
выполнить откат сразу на 2 шага и применить следующую продукцию
нетерминала *Operator*.

![](media/image10.png)

Рисунок 16. Дерево разбора и поток токенов (шаг 8)

Текущий символ --- терминал, совпадающий с терминалом из входного потока
токенов. Следовательно, необходимо перейти к следующему необработанному
узлу дерева разбора и следующему токену входного потока.

![](media/image11.png)

Рисунок 17. Дерево разбора и поток токенов (шаг 9)

Текущий символ --- терминал, совпадающий с терминалом из входного потока
токенов. Необходимо перейти к следующему символу.

![](media/image12.png)

Рисунок 18. Дерево разбора и поток токенов (шаг 10)

Текущий символ --- нетерминал, необходимо раскрыть его в соответствии с
первой продукцией.

![](media/image13.png)

Рисунок 19. Дерево разбора и поток токенов (шаг 11)

Нетерминал *Operator_If* раскрывается по первой продукции.

![](media/image14.png)

Рисунок 20. Дерево разбора и поток токенов (шаг 12)

Терминалы совпадают, переход к следующему символу.

![](media/image15.png)

Рисунок 21. Дерево разбора и поток токенов (шаг 13)

Нетерминал: дерево разбора дополняется по первой продукции.

![](media/image16.png)

Рисунок 22. Дерево разбора и поток токенов (шаг 14)

Нетерминал раскрывается по первой продукции, после чего на нескольких
последующих шагах происходит дальнейшее раскрытие нетерминалов и
совпадение терминалов до наступления ситуации, приведённой на рисунке
23.

![](media/image17.png)

Рисунок 23. Дерево разбора и поток токенов (перед откатом)

В данной ситуации терминал *else* из входного потока токенов не
совпадает с ожидаемым терминалом *endif*. По правилам метода
рекурсивного спуска необходимо сделать вывод о том, что выбор продукции,
частью которой является ожидаемый терминал, был ошибочным и необходимо
предпринять попытку применения следующей продукции.

Существенным недостатком метода рекурсивного спуска является
необходимость выполнения подобных откатов. Например, в данном случае до
момента отката было прочитано 8 терминалов и выполнено построение трёх
уровней поддерева, причём в ходе этого построения также производились
откаты. Очевидно, что это увеличивает время, требуемое методу
рекурсивного спуска для нахождения правильного порождения.

Следует также понимать, что решение о соответствии входного потока
токенов грамматике может быть принято только при совпадении двух
условий:

- прочитаны все символы входного потока;

- обработаны все узлы дерева разбора.

Для того, чтобы принять решение о несоответствии грамматике, необходимо,
чтобы в результате перебора всех возможных порождений ни одно из них не
подошло входному потоку токенов.

Очевидно, это означает, что в общем случае методу рекурсивного спуска
требуется просмотреть весь текст программы для того, чтобы оценить его
принадлежность грамматике, причём из-за откатов одни и те же терминалы
входного потока токенов будут просматриваться неоднократно, что особенно
неэффективно в случаях, когда синтаксическая ошибка допущена в самом
начале текста программы.

Вместе с тем, важным преимуществом метода рекурсивного спуска является
простота его реализации вручную.

Программная реализация метода рекурсивного спуска

Метод рекурсивного спуска в самом общем виде предполагает перебор всех
возможных альтернатив на каждом шаге порождения, что делает время работы
соответствующего синтаксического анализатора в худшем случае
экспоненциальным.

Для того, чтобы частично устранить эту проблему, на практике часто
используют разновидность метода рекурсивного спуска, основанную на так
называемых *грамматиках, разбирающих выражение* (parsing expression
grammars, PEG). Отличительной особенностью таких грамматик по сравнению
с обычными контекстно-свободными грамматиками является интерпретация
продукций в рамках нетерминалов.

Так в классических контекстно-свободных грамматиках все продукции одного
и того же нетерминала считаются равноправными независимо от порядка
записи, вследствие чего обнаружение какого-либо порождения заданной
строки не гарантирует отсутствия других порождений. В то же время PEG
предполагают, что каждая следующая продукция нетерминала может быть
применена только в том случае, если все предшествующие не подошли. Это
делает невозможным построение неоднозначной PEG.

Кроме того, код для реализации разбора по PEG оказывается намного проще
в написании.

Рассмотрим построение синтаксического анализатора, основанного на
грамматике, разбирающей выражение. Для этого преобразуем ранее
рассмотренную грамматику:

*Operator* → *Operator_If* \| int

*Operator_If* → if *Operator* then *Operator* endif

\| if *Operator* then *Operator* else *Operator* endif

Отличием нотации для PEG от классической нотации является замена
операции альтернативы \| на операцию упорядоченного выбора /. Перепишем
грамматику с учётом этой особенности:

*Operator* → *Operator_If* / int

*Operator_If* → if *Operator* then *Operator* endif

/ if *Operator* then *Operator* else *Operator* endif

Реализация синтаксического анализатора на основе грамматики, разбирающей
выражение, заключается в разработке набора процедур, рекурсивно
вызывающих друг друга, причём каждая из них соответствует одной
продукции либо одному из символов (терминалов либо нетерминалов)
грамматики.

Введём вспомогательный тип данных:

**type**

TTokenType = (ttInt, ttIf, ttThen, ttElse, ttEndIf);

PTokenType = \^TTokenType;

Последовательность токенов будем рассматривать как массив, для работы с
которым используется указатель на текущий элемент. При разработке
полноценного компилятора целесообразнее предусмотреть структуру данных,
реализующую потоковый интерфейс, для более эффективного взаимодействия
между лексическим и синтаксическим анализаторами.

**var**

Next: PTokenType;

Для всех терминалов грамматики будем использовать общую функцию, задача
которой заключается в сопоставлении ожидаемого в соответствии с
грамматикой терминала и фактически имеющегося во входном потоке токена.

**function** Term(**const** Expected: TTokenType): Boolean;

**begin**

Result := (Next\^ = Expected);

Inc(Next);

**end**;

Для каждого нетерминала разработаем функции, которые будут
последовательно перебирать продукции до тех пор, пока либо не будет
найдена подходящая, либо не окажется, что подходящих продукций нет.

**function** Operator: Boolean;

**var**

Save: PTokenType;

**begin**

Save := Next;

Result := True;

**if** Operator_1() **then** Exit;

Next := Save;

**if** Operator_2() **then** Exit;

Result := False;

**end**;

**function** OperatorIf: Boolean;

**var**

Save: PTokenType;

**begin**

Save := Next;

Result := True;

**if** OperatorIf_1() **then** Exit;

Next := Save;

**if** OperatorIf_2() **then** Exit;

Result := False;

**end**;

Для каждой продукции разрабатывается отдельная функция, отражающая
структуру этой продукции. Здесь и далее предполагается, что в настройках
проекта задано сокращённое вычисление логических выражений. Того же
эффекта можно достигнуть указанием директивы {\$B-}.

**function** Operator_1: Boolean;

**begin**

Result := OperatorIf();

**end**;

**function** Operator_2: Boolean;

**begin**

Result := Term(ttInt);

**end**;

**function** OperatorIf_1: Boolean;

**begin**

Result := Term(ttIf)

**and** Operator()

**and** Term(ttThen)

**and** Operator()

**and** Term(ttEndIf);

**end**;

**function** OperatorIf_2: Boolean;

**begin**

Result := Term(ttIf)

**and** Operator()

**and** Term(ttThen)

**and** Operator()

**and** Term(ttElse)

**and** Operator()

**and** Term(ttEndIf);

**end**;

Теперь для запуска синтаксического анализатора достаточно:

- установить указатель Next на начало потока токенов;

- вызвать функцию, соответствующую стартовому символу грамматики
  (*Operator*).

Приведённый анализатор выполняет только проверку на соответствие
последовательности токенов грамматике. При этом дерево разбора строится
неявно в форме последовательности рекурсивных вызовов.

Поскольку при написании компилятора, как правило, предпочтительнее
выполнять построение абстрактного синтаксического дерева, структура
которого определяется решаемой задачей, в данном методическом пособии
полный код такого анализатора не приводится. Тем не менее, основная идея
заключается в том, что при возврате True одной из функций,
соответствующих продукциям, фактически происходит применение такой
продукции, а значит, именно в эти моменты следует достраивать AST. Одна
из возможных реализация заключается в том, чтобы при успешном применении
продукции возвращать указатель на корень построенного поддерева, а в
случае, если продукция не подошла, возвращать нулевой указатель nil.

Левая рекурсия

Одним из слабых мест нисходящих методов синтаксического разбора (в том
числе всех разновидностей метода рекурсивного спуска, включая PEG)
является уязвимость к левой рекурсии. *Леворекурсивная грамматика* ---
такая грамматики, в котором в которой существует вывод (фрагмент
порождения) вида ![](media/image18.wmf), где ![](media/image19.wmf) ---
некоторый нетерминал, ![](media/image20.wmf) --- произвольная
последовательность терминалов и нетерминалов.

Рассмотрим следующую грамматику:

*S* → *S*a \| b

При попытке разработки синтаксического анализатора по методу
рекурсивного спуска (в том числе если считать грамматику разбирающей
выражение, т.е. заменить альтернативу упорядоченным выбором) получится
следующий код.

**type**

TTokenType = (ttA, ttB);

PTokenType = \^TTokenType;

**var**

Next: PTokenType;

**function** S: Boolean;

**var**

Save: PTokenType;

**begin**

Save := Next;

Result := True;

**if** S_1() **then** Exit;

Next := Save;

**if** S_2() **then** Exit;

Result := False;

**end**;

**function** S_1: Boolean;

**begin**

Result := S() **and** Term(ttA);

**end**;

**function** S_2: Boolean;

**begin**

Result := Term(ttB);

**end**;

Очевидной проблемой является взаимная рекурсия между функциями S и S_1.
Для запуска анализатора производится вызов функции S, которая после двух
присваиваний всегда вызывает функцию S_1. Функция же S_1 сразу после
получения управления вызывает функцию S. Таким образом, запуск такого
анализатора приведёт к бесконечной рекурсии, а его выполнение завершится
аварийно при переполнении стека.

Как и неоднозначность, левая рекурсия является свойством грамматики и
устраняется путём переписывания грамматики. В приведённом примере
грамматика может быть переписана следующим образом:

*S* → b*T*

*T* → a*T* \| ε

Задание

Для заданного вариантом языка разработать:

- **лексический анализатор**, распознающий необходимые лексемы;

- **грамматику** языка, включающую в себя базовые конструкции языка;

- **программное средство**, проверяющее исходный код программы на
  соответствие грамматике.

Лексический анализатор можно разработать вручную или использовать
утилиты-генераторы. Поддерживаемое подмножество языка согласовать с
преподавателем.

Таблица 9. Варианты заданий к лабораторной работе №3

  ------------------------------------------------------------------------
  Номер      Язык/формат                Примечания
  варианта                              
  ---------- -------------------------- ----------------------------------
  1          Pascal/Delphi              

  2          C/C++                      

  3          Basic                      

  4          C#/Java                    

  5          Python                     

  6          SQL                        

  7          JSON                       

  8          HTML                       

  9          PHP                        

  10         Markdown                   

  11         Go                         

  12         Rust                       

  13         Ада                        

  14         Модула                     

  15         Lisp                       

  16         Erlang
  ------------------------------------------------------------------------
