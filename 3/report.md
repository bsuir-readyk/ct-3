> Министерство образования Республики Беларусь
>
> Учреждение образования
>
> «Белорусский государственный университет информатики и
> радиоэлектроники»
>
> Факультет компьютерных систем и сетей Кафедра ПОИТ

Дисциплина «Компиляторные технологии»

> ОТЧЁТ
>
> к лабораторной работе №3
>
> РАЗРАБОТКА СИНТАКСИЧЕСКОГО АНАЛИЗАТОРА, ОСНОВАННОГО НА МЕТОДЕ
> РЕКУРСИВНОГО СПУСКА

Вариант 16

> Студент группы
>
> №451002
>
> Мищенко Н.В.
>
> Преподаватель Болтак С.В.
>
> Минск 2025
>
> **СОДЕРЖАНИЕ**

[Введение 3](#_bookmark0)

1.  1.  
    2.  
    3.  
    4.  
2.  1.  
    2.  
    3.  
    4.  
    5.  

[Описание лабораторной работы 4](#_bookmark1)[Задание к лабораторной
работе 4](#задание-к-лабораторной-работе)[Базовые допустимые конструкции
языка 4](#базовые-допустимые-конструкции-языка)[Использованные лексемы
4](#использованные-лексемы)[Эскиз ожидаемого результата
5](#эскиз-ожидаемого-результата)[Реализация синтаксического анализатора
6](#_bookmark6)[Грамматика для базовых конструкций
6](#грамматика-для-базовых-конструкций)[Построение дерева разбора
7](#_bookmark8)[Код и запуск программы
8](#код-и-запуск-программы)[Тестирование программы
16](#тестирование-программы)[Вывод по второй главе
18](#_bookmark11)[Заключение 19](#_bookmark12)

[Список использованных источников 20](#_bookmark13)

# ОПИСАНИЕ ЛАБОРАТОРНОЙ РАБОТЫ

## Задание к лабораторной работе

> В шестнадцатом варианте лабораторной работы объектом для проверки является
> код на Erlang. Необходимо разработать лексический анализатор, грамматику
> языка как минимум для трёх базовых конструкций и программное средство
> на языке C, проверяющее исходный код на соответствие грамматике. При
> создании лексического анализатора допускается использование
> утилит-генераторов. Поддерживаемое подмножество языка согласовать с
> преподавателем.
>
> На каждом этапе анализа программное средство должно выводить сообщение
> о корректности или некорректности исходного кода.
>
> Ввод осуществляется из текстового файла.

## Базовые допустимые конструкции языка

В рамках синтаксического анализа поддерживается сокращённое подмножество
языка программирования Erlang.\
Лексический анализатор выделяет основные элементы Erlang-модуля,
необходимые для построения дерева структуры.\
К допустимым конструкциям относятся:

- **объявление модуля** (-module(name).), определяющее имя модуля;

- **объявление экспорта** (-export([main/0]).), указывающее экспортируемые функции;

- **определение функции main** (main() -> body.), содержащее тело функции;

- **вызов io:format** (io:format("строка")), выводящий строку;

- **условный оператор if** с одной или двумя ветками:
  - if ЦИФРА -> операторы end
  - if ЦИФРА -> операторы ; true -> операторы end;

- **атом ok**, используемый как возвращаемое значение;

- **последовательность операторов**, разделённых запятыми;

- **пробельные символы** (пробелы, табуляции и переходы строк), которые **игнорируются** и не превращаются в токены.

## Использованные лексемы

В лексическом анализе используются следующие токены\
(в скобках указаны их имена в перечислении Types программы):

- **NEXT** --- символы перевода строки и табуляции (\n, \r\n, \t);

- **SPACE** --- пробел;

- **MODULE** --- ключевое слово -module;

- **EXPORT** --- ключевое слово -export;

- **OPEN_PAREN** --- открывающая круглая скобка (;

- **CLOSE_PAREN** --- закрывающая круглая скобка );

- **OPEN_BRACKET** --- открывающая квадратная скобка [;

- **CLOSE_BRACKET** --- закрывающая квадратная скобка ];

- **SLASH** --- символ деления /;

- **ZERO** --- цифра 0 (для арности функции);

- **MAIN** --- идентификатор main;

- **ARROW** --- стрелка ->;

- **DOT** --- точка .;

- **IO_FORMAT** --- вызов io:format;

- **STRING** --- строковый литерал в двойных кавычках;

- **COMMA** --- запятая ,;

- **IF** --- ключевое слово if;

- **DIGIT** --- цифра от 1 до 9 (условие);

- **END** --- ключевое слово end;

- **SEMICOLON** --- точка с запятой ;;

- **TRUE** --- атом true;

- **OK** --- атом ok.

Эти лексемы используются парсером для проверки синтаксической корректности
Erlang-модуля: структуры объявлений, определений функций и операторов.

## Эскиз ожидаемого результата

> Допустим, дан следующий код на Erlang:

-module(main).

-export([main/0]).

main() ->

    io:format("Hello World"),

    io:format("Second message"),

    if 3 ->

        io:format("condition is true"),

        io:format("more output")

    end,

    if 5 ->

        io:format("simple branch")

    ; true ->

        io:format("else branch"),

        if 1 ->

            io:format("nested if")

        end

    end,

    ok.

> Тогда результат работы программы будет выглядеть следующим образом:

accept

# РЕАЛИЗАЦИЯ СИНТАКСИЧЕСКОГО АНАЛИЗАТОРА

## Грамматика для базовых конструкций

program   →  -module(main). -export([main/0]). main() -> body.\
body      →  operator (, operator)*\
operator  →  io_format | if_stmt | ok

io_format →  io:format("строка")\
if_stmt   →  if DIGIT -> body end\
          |  if DIGIT -> body ; true -> body end

**Терминальные символы и их форма записи**

MODULE → \'-module\'\
EXPORT → \'-export\'\
MAIN → \'main\'\
OPEN_PAREN → \'(\'\
CLOSE_PAREN → \')\'\
OPEN_BRACKET → \'[\'\
CLOSE_BRACKET → \']\'\
SLASH → \'/\'\
ZERO → \'0\'\
ARROW → \'->\'\
DOT → \'.\'\
IO_FORMAT → \'io:format\'\
STRING → \'\"\' \[\^\"\]\* \'\"\'\
COMMA → \',\'\
IF → \'if\'\
DIGIT → \[1-9\]\
END → \'end\'\
SEMICOLON → \';\'\
TRUE → \'true\'\
OK → \'ok\'

## Построение дерева разбора

> Допустим, на вход дан следующий код на Erlang:

-module(main).

-export([main/0]).

main() ->

    io:format("Test"),

    if 1 ->

        ok

    end,

    ok.

На рисунке 2.2.1 изображено дерево разбора для данного скрипта.

```
                            program
                               |
        +----------------------+----------------------+
        |                      |                      |
   -module(main).      -export([main/0]).      main() -> body.
                                                      |
                                                    body
                                                      |
                    +----------------+----------------+
                    |                |                |
               io_format          if_stmt            ok
                    |                |
           io:format("Test")         |
                              +------+------+
                              |             |
                         if 1 ->          end
                              |
                            body
                              |
                             ok
```

> Рисунок 2.2.1 -- Дерево разбора кода на Erlang

## Код и запуск программы

> Программное средство было написано на языке C. Однако представленный
> код не является файлом с расширением .c в привычном понимании. Код
> написан под утилиту-генератор flex. После этого программа
> сгенерировала lex.yy.c, который впоследствии был скомпилирован в
> исполняемый файл лексического анализатора lexer. Чтобы запустить
> программу для анализа текста в файле test.txt необходимо в терминале ввести
> команду "make run", предварительно перейдя в директорию
> расположения исходных файлов.
>
> Код text.l выглядит следующим образом:

%option main

%option noyywrap

%option noinput

%option nounput

NEXT    \\n\|\\r\\n\|\\t

STRING  \\"[^\\"]\*\\"

DIGIT   [1-9]

%%

{NEXT}      { printf("0\\n"); }

[ ]         { printf("1\\n"); }

"-module"   { printf("2\\n"); }

"-export"   { printf("3\\n"); }

[(]         { printf("4\\n"); }

[)]         { printf("5\\n"); }

"["         { printf("6\\n"); }

"]"         { printf("7\\n"); }

"/"         { printf("8\\n"); }

"0"         { printf("9\\n"); }

main        { printf("10\\n"); }

"->"        { printf("11\\n"); }

"."         { printf("12\\n"); }

"io:format" { printf("13\\n"); }

{STRING}    { printf("14\\n"); }

","         { printf("15\\n"); }

if          { printf("16\\n"); }

{DIGIT}     { printf("17\\n"); }

end         { printf("18\\n"); }

";"         { printf("19\\n"); }

true        { printf("20\\n"); }

ok          { printf("21\\n"); }

%%

Код main.c выглядит следующим образом:

#include \<stdio.h\>

#include \<stdbool.h\>

#define MAX 500

bool body();

bool operator_();

bool io_format();

bool if_stmt();

typedef enum Types {

    NEXT = 0,

    SPACE,

    MODULE,

    EXPORT,

    OPEN_PAREN,

    CLOSE_PAREN,

    OPEN_BRACKET,

    CLOSE_BRACKET,

    SLASH,

    ZERO,

    MAIN,

    ARROW,

    DOT,

    IO_FORMAT,

    STRING,

    COMMA,

    IF,

    DIGIT,

    END,

    SEMICOLON,

    TRUE,

    OK,

} lexeme;

int next = 0, count = 0;

int token[MAX];

bool term(const lexeme expected) {

    return expected == token[next++];

}

bool curr(const lexeme expected) {

    return expected == token[next];

}

*// program → -module(ATOM). -export([main/0]). main() -> body.*

*// Упрощение: вместо ATOM используем main как имя модуля*

bool program() {

    bool res = true;

    *// -module(main).*

    if (!term(MODULE)) res = false;

    if (!term(OPEN_PAREN)) res = false;

    if (!term(MAIN)) res = false;

    if (!term(CLOSE_PAREN)) res = false;

    if (!term(DOT)) res = false;

    *// -export([main/0]).*

    if (!term(EXPORT)) res = false;

    if (!term(OPEN_PAREN)) res = false;

    if (!term(OPEN_BRACKET)) res = false;

    if (!term(MAIN)) res = false;

    if (!term(SLASH)) res = false;

    if (!term(ZERO)) res = false;

    if (!term(CLOSE_BRACKET)) res = false;

    if (!term(CLOSE_PAREN)) res = false;

    if (!term(DOT)) res = false;

    *// main() -> body.*

    if (!term(MAIN)) res = false;

    if (!term(OPEN_PAREN)) res = false;

    if (!term(CLOSE_PAREN)) res = false;

    if (!term(ARROW)) res = false;

    if (!body()) res = false;

    if (!term(DOT)) res = false;

    return res;

}

*// body → operator (, operator)\**

bool body() {

    if (!operator_()) return false;

    while (curr(COMMA)) {

        next++; *// consume comma*

        if (!operator_()) return false;

    }

    return true;

}

*// operator → io_format | if_stmt | ok*

bool operator_() {

    int save = next;

    return (next = save, io_format()) \|\|

           (next = save, if_stmt()) \|\|

           (next = save, term(OK));

}

*// io_format → io:format("string")*

bool io_format() {

    return term(IO_FORMAT) && term(OPEN_PAREN) && term(STRING) && term(CLOSE_PAREN);

}

*// if_stmt → if DIGIT -> body ; true -> body end*

*//         | if DIGIT -> body end*

bool if_stmt() {

    int save = next;

    *// Сначала пробуем if с else (true ->)*

    if (term(IF) && term(DIGIT) && term(ARROW) && body() && 

        term(SEMICOLON) && term(TRUE) && term(ARROW) && body() && term(END)) {

        return true;

    }

    *// Затем пробуем простой if*

    next = save;

    return term(IF) && term(DIGIT) && term(ARROW) && body() && term(END);

}

void read() {

    int temp;

    FILE \*f;

    f = fopen("out.txt", "r+t");

    while (fscanf(f, "%d", &temp) == 1) {

        if ((temp != SPACE) && (temp != NEXT)) {

            token[count++] = temp;

        }

    }

    fclose(f);

}

int main() {

    read();

    printf(program() ? "accept\\n" : "reject\\n");

    return 0;

}

## Тестирование программы

> В таблице 1 пердставлено некоторое количесвто тестов для отладки
> программы и отражено их соответствие ожидаемому результату.
>
> Таблица 1 -- Тестирование программы

+-------------------------------+---------------+---------------+-------------+
| > Код исходного файла         | > Ожидаемый   | > Фактический | > Результат |
|                               | > результат   | > результат   | > теста     |
|                               | > работы      | > работы      |             |
|                               | > программы   | > программы   |             |
+===============================+:==============+:==============+:===========:+
| > -module(main).              | > accept      | > accept      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     io:format("Hello"),     |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > accept      | > accept      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     if 1 ->                 |               |               |             |
| >                             |               |               |             |
| >         ok                  |               |               |             |
| >                             |               |               |             |
| >     end,                    |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > accept      | > accept      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     if 5 ->                 |               |               |             |
| >                             |               |               |             |
| >         io:format("true")   |               |               |             |
| >                             |               |               |             |
| >     ; true ->               |               |               |             |
| >                             |               |               |             |
| >         io:format("false")  |               |               |             |
| >                             |               |               |             |
| >     end,                    |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > accept      | > accept      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     io:format("A"),         |               |               |             |
| >                             |               |               |             |
| >     io:format("B"),         |               |               |             |
| >                             |               |               |             |
| >     if 3 ->                 |               |               |             |
| >                             |               |               |             |
| >         io:format("C"),     |               |               |             |
| >                             |               |               |             |
| >         if 2 ->             |               |               |             |
| >                             |               |               |             |
| >             ok              |               |               |             |
| >                             |               |               |             |
| >         end                 |               |               |             |
| >                             |               |               |             |
| >     end,                    |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     io:format("test")       |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
| >                             |               |               |             |
| > (пропущена запятая)         |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     if 1 ->                 |               |               |             |
| >                             |               |               |             |
| >         ok                  |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
| >                             |               |               |             |
| > (пропущен end)              |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     ok                      |               |               |             |
| >                             |               |               |             |
| > (пропущена точка)           |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
| >                             |               |               |             |
| > (пропущен -export)          |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     io:format("test".       |               |               |             |
| >                             |               |               |             |
| > (незакрытая скобка)         |               |               |             |
+-------------------------------+---------------+---------------+-------------+
| > -module(main).              | > reject      | > reject      | > Пройден   |
| >                             |               |               |             |
| > -export([main/0]).          |               |               |             |
| >                             |               |               |             |
| > main() ->                   |               |               |             |
| >                             |               |               |             |
| >     if 1 ->                 |               |               |             |
| >                             |               |               |             |
| >         ok                  |               |               |             |
| >                             |               |               |             |
| >     ; true                  |               |               |             |
| >                             |               |               |             |
| >         ok                  |               |               |             |
| >                             |               |               |             |
| >     end,                    |               |               |             |
| >                             |               |               |             |
| >     ok.                     |               |               |             |
| >                             |               |               |             |
| > (пропущена стрелка          |               |               |             |
| > после true)                 |               |               |             |
+-------------------------------+---------------+---------------+-------------+
